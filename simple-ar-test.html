<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚·ãƒ³ãƒ—ãƒ«ARãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }
        
        #ar-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #camera-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            opacity: 1;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 10;
            font-size: 12px;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ar-container">
        <video id="camera-video" autoplay muted playsInline></video>
        <canvas id="three-canvas"></canvas>
        
        <div id="status">åˆæœŸåŒ–ä¸­...</div>
        
        <div id="instructions">
            ç”»é¢ã‚’ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã—ã¦3Dãƒ¢ãƒ‡ãƒ«ã‚’é…ç½®
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        class SimpleAR {
            constructor() {
                this.video = document.getElementById('camera-video');
                this.canvas = document.getElementById('three-canvas');
                this.status = document.getElementById('status');
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.models = [];
                this.loadedGLTF = null;
                
                this.init();
            }
            
            async init() {
                try {
                    this.updateStatus('Three.jsåˆæœŸåŒ–ä¸­...');
                    this.initThree();
                    
                    this.updateStatus('ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–ä¸­...');
                    await this.initCamera();
                    
                    this.updateStatus('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...');
                    await this.loadModel();
                    
                    this.updateStatus('ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®šä¸­...');
                    this.setupEvents();
                    
                    this.updateStatus('âœ… ARæº–å‚™å®Œäº†');
                    this.startRender();
                    
                } catch (error) {
                    console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
            
            async initCamera() {
                // è¨ºæ–­ã§æˆåŠŸã—ãŸè¨­å®šã‚’ä½¿ç”¨
                const constraints = [
                    { video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } },
                    { video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } } },
                    { video: { facingMode: 'environment' } },
                    { video: true }
                ];
                
                for (let i = 0; i < constraints.length; i++) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia(constraints[i]);
                        this.video.srcObject = stream;
                        
                        await new Promise(resolve => {
                            this.video.addEventListener('loadedmetadata', resolve, { once: true });
                        });
                        
                        // âœ… æ ¹æœ¬ä¿®æ­£ï¼šVideoTextureã‚’èƒŒæ™¯ã«è¨­å®š
                        this.videoTexture = new THREE.VideoTexture(this.video);
                        this.videoTexture.colorSpace = THREE.SRGBColorSpace;
                        this.scene.background = this.videoTexture;
                        console.log('âœ… VideoTextureèƒŒæ™¯è¨­å®šå®Œäº†');
                        
                        console.log(`âœ… ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–æˆåŠŸ (è¨­å®š${i + 1})`);
                        return;
                    } catch (error) {
                        console.warn(`âš ï¸ ã‚«ãƒ¡ãƒ©è¨­å®š${i + 1}å¤±æ•—:`, error);
                        if (i === constraints.length - 1) throw error;
                    }
                }
            }
            
            initThree() {
                // ã‚·ãƒ¼ãƒ³
                this.scene = new THREE.Scene();
                
                // âœ… ã‚«ãƒ¡ãƒ©è¨­å®šã‚’WebRTCãƒ¢ãƒ¼ãƒ‰ã¨çµ±ä¸€
                this.camera = new THREE.PerspectiveCamera(
                    45, // FOVçµ±ä¸€ï¼ˆ75â†’45ï¼‰
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 0, 0);
                
                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ï¼ˆè¨ºæ–­ã§æˆåŠŸã—ãŸè¨­å®šï¼‰
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: true
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                // âœ… èƒŒæ™¯ã¯VideoTextureã§å‡¦ç†ã™ã‚‹ãŸã‚ã‚¯ãƒªã‚¢ä¸è¦
                
                // ãƒ©ã‚¤ãƒˆ
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
            }
            
            async loadModel() {
                console.log('ğŸ” ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿é–‹å§‹...');
                this.updateStatus('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...');
                
                try {
                    const loader = new GLTFLoader();
                    
                    // âœ… è»½é‡ãƒ¢ãƒ‡ãƒ«ã§ãƒ†ã‚¹ãƒˆï¼ˆè¤‡é›‘ãªMixamoæ —ãƒ¢ãƒ‡ãƒ«ã‚’å›é¿ï¼‰
                    const possibleUrls = [
                        '/assets/sample.glb',
                        '/public/assets/sample.glb',
                        'https://192.168.179.2:3004/assets/sample.glb',
                        './assets/sample.glb'
                    ];
                    
                    let modelLoaded = false;
                    let lastError = null;
                    
                    for (const modelUrl of possibleUrls) {
                        try {
                            console.log(`ğŸ” è©¦è¡Œä¸­: ${modelUrl}`);
                            this.updateStatus(`ãƒ¢ãƒ‡ãƒ«è©¦è¡Œ: ${modelUrl}`);
                            
                            // ã¾ãšãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
                            const response = await fetch(modelUrl, { method: 'HEAD' });
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            console.log(`âœ… ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèªæˆåŠŸ: ${modelUrl}`);
                            
                            // GLTFãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
                            this.loadedGLTF = await new Promise((resolve, reject) => {
                                loader.load(
                                    modelUrl,
                                    (gltf) => {
                                        console.log('âœ… GLTFèª­ã¿è¾¼ã¿æˆåŠŸ:', gltf);
                                        resolve(gltf);
                                    },
                                    (progress) => {
                                        console.log('ğŸ“Š èª­ã¿è¾¼ã¿é€²æ—:', (progress.loaded / progress.total) * 100 + '%');
                                    },
                                    (error) => {
                                        console.error('âŒ GLTFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                                        reject(error);
                                    }
                                );
                            });
                            
                            // âœ… AnimationMixerè¨­å®šï¼ˆGLTFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
                            const gltf = this.loadedGLTF;
                            if (gltf.animations && gltf.animations.length > 0) {
                                this.mixer = new THREE.AnimationMixer(gltf.scene);
                                const action = this.mixer.clipAction(gltf.animations[0]);
                                action.setLoop(THREE.LoopRepeat);
                                action.play();
                                console.log('âœ… GLTFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹:', gltf.animations[0].name);
                            }
                            
                            console.log('âœ… GLTFãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œå…¨æˆåŠŸ!');
                            this.updateStatus('âœ… æ —ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ');
                            modelLoaded = true;
                            break;
                            
                        } catch (error) {
                            console.warn(`âš ï¸ ${modelUrl} å¤±æ•—:`, error.message);
                            lastError = error;
                        }
                    }
                    
                    if (!modelLoaded) {
                        throw new Error(`å…¨ã¦ã®URLè©¦è¡Œå¤±æ•—ã€‚æœ€å¾Œã®ã‚¨ãƒ©ãƒ¼: ${lastError?.message}`);
                    }
                    
                } catch (error) {
                    console.error('âŒ å…¨ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—:', error);
                    this.updateStatus(`âŒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: ${error.message}`);
                    
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚­ãƒ¥ãƒ¼ãƒ–ä½œæˆ
                    console.log('ğŸ”¶ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚­ãƒ¥ãƒ¼ãƒ–ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
                    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const material = new THREE.MeshPhongMaterial({ color: 0xff6600 });
                    this.defaultModel = new THREE.Mesh(geometry, material);
                }
            }
            
            setupEvents() {
                // ğŸ”§ ã‚¹ãƒ­ãƒƒãƒˆãƒ«åˆ¶å¾¡ã§ç‚¹æ»…é˜²æ­¢
                let lastPlacement = 0;
                const PLACEMENT_COOLDOWN = 500; // 0.5ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                
                const placeModel = (event) => {
                    const now = Date.now();
                    if (now - lastPlacement < PLACEMENT_COOLDOWN) {
                        console.log('â³ é…ç½®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã€ç„¡è¦–');
                        return;
                    }
                    lastPlacement = now;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    
                    let clientX, clientY;
                    if (event.touches && event.touches[0]) {
                        clientX = event.touches[0].clientX;
                        clientY = event.touches[0].clientY;
                        event.preventDefault();
                    } else {
                        clientX = event.clientX;
                        clientY = event.clientY;
                    }
                    
                    // ç”»é¢åº§æ¨™ã‚’3Dåº§æ¨™ã«å¤‰æ›
                    const x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // âœ… å›ºå®šè·é›¢é…ç½®ï¼ˆä»–ã®AIæ¨å¥¨å€¤ï¼‰
                    const distance = 1.5; // 1.5må‰æ–¹ï¼ˆå®‰å®šé…ç½®ï¼‰
                    const position = new THREE.Vector3(
                        x * 0.8, // ã‚ˆã‚Šåºƒã„ç¯„å›²ã«é…ç½®
                        y * 0.8,
                        -distance
                    );
                    
                    console.log('ğŸ¯ ãƒ¢ãƒ‡ãƒ«é…ç½®å®Ÿè¡Œ:', { x, y, position });
                    this.placeModelAtPosition(position);
                };
                
                // ã‚ˆã‚Šç¢ºå®Ÿãªã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                this.canvas.addEventListener('touchstart', placeModel, { 
                    passive: false, 
                    capture: true 
                });
                this.canvas.addEventListener('click', placeModel, { 
                    capture: true 
                });
                
                // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                console.log('âœ… ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†ï¼ˆã‚¹ãƒ­ãƒƒãƒˆãƒ«åˆ¶å¾¡ä»˜ãï¼‰');
            }
            
            placeModelAtPosition(position) {
                let model;
                
                if (this.loadedGLTF) {
                    model = this.loadedGLTF.scene.clone();
                    
                    // ğŸ”§ ã‚ˆã‚Šå°ã•ãªã‚µã‚¤ã‚ºã«èª¿æ•´ï¼ˆARé©æ­£ã‚µã‚¤ã‚ºï¼‰
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const targetSize = 1.0; // âœ… 1måŸºæº–ï¼ˆä»–ã®AIæ¨å¥¨ï¼‰
                    const scale = targetSize / maxSize;
                    model.scale.setScalar(scale);
                    
                    console.log(`ğŸ”§ æ —ãƒ¢ãƒ‡ãƒ«ã‚µã‚¤ã‚ºèª¿æ•´: ${size.x.toFixed(2)}â†’${targetSize} (ã‚¹ã‚±ãƒ¼ãƒ«: ${scale.toFixed(3)})`);
                    
                } else {
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚­ãƒ¥ãƒ¼ãƒ–
                    const geometry = new THREE.BoxGeometry(1.0, 1.0, 1.0); // âœ… 1mã‚­ãƒ¥ãƒ¼ãƒ–ï¼ˆçµ±ä¸€ï¼‰
                    const material = new THREE.MeshPhongMaterial({ 
                        color: Math.random() * 0xffffff 
                    });
                    model = new THREE.Mesh(geometry, material);
                }
                
                // âœ… å›ºå®šè·é›¢é…ç½®ï¼ˆä»–ã®AIæ¨å¥¨ï¼‰
                const adjustedPosition = position.clone();
                adjustedPosition.z = Math.min(adjustedPosition.z, -1.5); // æœ€ä½1.5må…ˆï¼ˆå®‰å®šé…ç½®ï¼‰
                
                model.position.copy(adjustedPosition);
                // âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ©ã‚°è¨­å®šï¼ˆæ‰‹å‹•å›è»¢ vs GLTFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                model.userData.hasGLTFAnimation = !!this.loadedGLTF?.animations?.length;
                model.userData.rotationSpeed = model.userData.hasGLTFAnimation ? 0 : 0.01;
                
                this.scene.add(model);
                this.models.push(model);
                
                console.log(`âœ… ãƒ¢ãƒ‡ãƒ«é…ç½®: ${this.models.length}å€‹ç›®`, adjustedPosition);
                this.updateStatus(`âœ… ãƒ¢ãƒ‡ãƒ«é…ç½®å®Œäº† (${this.models.length}å€‹) - è·é›¢: ${Math.abs(adjustedPosition.z).toFixed(1)}m`);
            }
            
            startRender() {
                // âœ… æ ¹æœ¬ä¿®æ­£ï¼šå˜ä¸€RAF + Clockçµ±åˆã§mixerç«¶åˆè§£æ¶ˆ
                const clock = new THREE.Clock();
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    const delta = clock.getDelta();
                    
                    // âœ… AnimationMixeræ›´æ–°ï¼ˆGLTFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    if (this.mixer) {
                        this.mixer.update(delta);
                    }
                    
                    // ãƒ¢ãƒ‡ãƒ«å›è»¢ï¼ˆæ‰‹å‹•å›è»¢ï¼‰
                    this.models.forEach(model => {
                        if (model.userData.rotationSpeed && !model.userData.hasGLTFAnimation) {
                            model.rotation.y += model.userData.rotationSpeed;
                        }
                    });
                    
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
                console.log('ğŸ¬ çµ±åˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹');
            }
            
            updateStatus(message) {
                this.status.textContent = message;
                console.log('ğŸ“± Status:', message);
            }
        }
        
        // è‡ªå‹•èµ·å‹•
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleAR();
        });
        
    </script>
</body>
</html>