<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒãƒ¼ã‚«ãƒ¼ARãƒ†ã‚¹ãƒˆ - æœ€å°æ§‹æˆ</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    
    #arContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      max-width: 300px;
      font-size: 12px;
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      z-index: 1000;
    }
    
    .error {
      color: #ff4444;
    }
    
    .success {
      color: #44ff44;
    }
    
    .warning {
      color: #ffaa44;
    }
  </style>
</head>
<body>
  <div id="arContainer">
    <div id="status">
      <div id="statusText">åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <div id="instructions">
      <h3>ğŸ¯ ãƒãƒ¼ã‚«ãƒ¼ARãƒ†ã‚¹ãƒˆ</h3>
      <p>HIROãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚«ãƒ¡ãƒ©ã«å‘ã‘ã¦ãã ã•ã„</p>
      <p><a href="https://ar-js-org.github.io/AR.js/data/images/HIRO.jpg" target="_blank" style="color: #4CAF50;">HIROãƒãƒ¼ã‚«ãƒ¼ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a></p>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- AR.js -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/three.js/build/ar-threex.js"></script>

  <script>
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºç”¨
    const statusEl = document.getElementById('statusText');
    
    function updateStatus(message, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${message}`);
      statusEl.innerHTML = `<span class="${type}">${message}</span>`;
    }

    // ãƒ¡ã‚¤ãƒ³åˆæœŸåŒ–é–¢æ•°
    async function resolveAssetUrl(candidates) {
      for (const url of candidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const buf = await res.clone().arrayBuffer();
          const size = buf.byteLength;
          const name = (url || '').toString();
          const isCamera = name.includes('camera_para');
          const minSize = isCamera ? 1024 : 256;
          if (size < minSize) continue;
          try {
            const head = new Uint8Array(buf).slice(0, 256);
            const text = new TextDecoder().decode(head).toLowerCase();
            if (text.includes("couldn't find the requested file") || text.includes('<html') || text.includes('not found')) continue;
          } catch {}
          return url;
        } catch {}
      }
      return candidates.find(Boolean);
    }

    async function initMarkerAR() {
      updateStatus('ãƒãƒ¼ã‚«ãƒ¼ARåˆæœŸåŒ–é–‹å§‹...', 'info');
      
      try {
        // AR.js ã®èª­ã¿è¾¼ã¿ç¢ºèª
        if (!window.THREEx || !window.THREEx.ArToolkitSource) {
          throw new Error('AR.js ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
        }
        updateStatus('âœ… AR.js ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç¢ºèªå®Œäº†', 'success');

        // Three.js åŸºæœ¬è¦ç´ 
        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        const renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true 
        });

        const container = document.getElementById('arContainer');
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0px';
        renderer.domElement.style.left = '0px';
        container.appendChild(renderer.domElement);

        updateStatus('âœ… Three.js ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®šå®Œäº†', 'success');

        // AR.js ã‚«ãƒ¡ãƒ©ã‚½ãƒ¼ã‚¹
        const arToolkitSource = new THREEx.ArToolkitSource({
          sourceType: 'webcam',
          sourceWidth: 640,
          sourceHeight: 480,
          displayWidth: 640,
          displayHeight: 480
        });

        updateStatus('ğŸ“¹ ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹è¦æ±‚ä¸­...', 'warning');

        // ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
        await new Promise((resolve, reject) => {
          arToolkitSource.init(
            () => {
              updateStatus('âœ… ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹æˆåŠŸ', 'success');
              arToolkitSource.onResize();
              arToolkitSource.copySizeTo(renderer.domElement);
              resolve();
            },
            (error) => {
              updateStatus(`âŒ ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹å¤±æ•—: ${error.message}`, 'error');
              reject(error);
            }
          );
        });

        // ã‚¢ã‚»ãƒƒãƒˆURLè§£æ±ºï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å„ªå…ˆã€å¤±æ•—æ™‚ã¯CDN/Rawï¼‰
        const cameraParametersUrl = await resolveAssetUrl([
          '/arjs/camera_para.dat',
          'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/three.js/data/camera_para.dat',
          'https://unpkg.com/@ar-js-org/ar.js@3.4.5/three.js/data/camera_para.dat',
          'https://raw.githubusercontent.com/artoolkitx/jsartoolkit5/master/examples/Three.js/data/camera_para.dat'
        ]);

        // AR.js ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
        const arToolkitContext = new THREEx.ArToolkitContext({
          cameraParametersUrl,
          detectionMode: 'mono',
          matrixCodeType: '3x3',
          canvasWidth: 640,
          canvasHeight: 480
        });

        updateStatus('ğŸ¯ ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­...', 'warning');

        // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆæœŸåŒ–
        await new Promise((resolve) => {
          arToolkitContext.init(() => {
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            updateStatus('âœ… ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'success');
            resolve();
          });
        });

        // ãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒˆ
        const markerRoot = new THREE.Group();
        scene.add(markerRoot);

        // ãƒãƒ¼ã‚«ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        // ãƒãƒ¼ã‚«ãƒ¼URLè§£æ±º
        const patternUrl = await resolveAssetUrl([
          '/arjs/patt.hiro',
          'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/three.js/data/patt.hiro',
          'https://unpkg.com/@ar-js-org/ar.js@3.4.5/three.js/data/patt.hiro',
          'https://raw.githubusercontent.com/artoolkitx/jsartoolkit5/master/examples/Three.js/data/patt.hiro'
        ]);

        const markerControls = new THREEx.ArMarkerControls(
          arToolkitContext, 
          markerRoot, 
          {
            type: 'pattern',
            patternUrl
          }
        );

        // ãƒ†ã‚¹ãƒˆç”¨ã‚­ãƒ¥ãƒ¼ãƒ–
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.y = 0.5;
        markerRoot.add(cube);

        // ãƒ©ã‚¤ãƒˆ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        updateStatus('âœ… 3Dè¦ç´ é…ç½®å®Œäº†', 'success');

        // ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºçŠ¶æ…‹ç›£è¦–
        let lastMarkerVisible = false;
        setInterval(() => {
          const isVisible = markerRoot.visible;
          if (isVisible !== lastMarkerVisible) {
            if (isVisible) {
              updateStatus('ğŸ¯ ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºï¼ç·‘ã®ã‚­ãƒ¥ãƒ¼ãƒ–ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã¾ã™', 'success');
            } else {
              updateStatus('âš ï¸ ãƒãƒ¼ã‚«ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'warning');
            }
            lastMarkerVisible = isVisible;
          }
        }, 500);

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
          requestAnimationFrame(animate);
          
          if (arToolkitSource.ready) {
            arToolkitContext.update(arToolkitSource.domElement);
          }
          
          // ã‚­ãƒ¥ãƒ¼ãƒ–å›è»¢
          cube.rotation.x += 0.01;
          cube.rotation.y += 0.01;
          
          renderer.render(scene, camera);
        }

        animate();
        updateStatus('ğŸš€ ãƒãƒ¼ã‚«ãƒ¼ARé–‹å§‹ï¼HIROãƒãƒ¼ã‚«ãƒ¼ã‚’å‘ã‘ã¦ãã ã•ã„', 'success');

      } catch (error) {
        updateStatus(`âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
        console.error('MarkerAR Error:', error);
      }
    }

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«åˆæœŸåŒ–
    window.addEventListener('load', () => {
      setTimeout(initMarkerAR, 500);
    });

    // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
    window.addEventListener('resize', () => {
      // ç°¡æ˜“ãƒªã‚µã‚¤ã‚ºå‡¦ç†
      location.reload();
    });
  </script>
</body>
</html>
