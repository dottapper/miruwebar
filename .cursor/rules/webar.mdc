---
description:
globs:
alwaysApply: true
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to

# プロジェクトルール

# ミルウェブ AR プロジェクトルール

## 1. アーキテクチャルルール

### 1.1 ファイル構造

src/
├── views/ # ページレベルのコンポーネント
├── components/ # 再利用可能なコンポーネント
│ └── loading-screen/ # ローディング画面関連
├── storage/ # データ永続化ロジック
├── api/ # 外部 API 通信
├── utils/ # ユーティリティ関数
├── styles/ # CSS ファイル
└── loader/ # アセット読み込み関連

### 1.2 命名規則

- **ファイル名**: kebab-case (`ar-viewer.js`, `project-store.js`)
- **関数名**: camelCase (`initARViewer`, `saveProject`)
- **定数**: UPPER_SNAKE_CASE (`STORAGE_KEY`, `MAX_FILE_SIZE`)
- **クラス名**: PascalCase (`LoadingManager`, `ProjectStore`)
- **CSS クラス**: kebab-case (`.editor-container`, `.loading-screen`)

### 1.3 モジュール設計

- **単一責任の原則**: 各ファイルは 1 つの明確な責任を持つ
- **依存関係の最小化**: 循環依存を避ける
- **インターフェース分離**: 大きなモジュールは小さな機能に分割

## 2. コーディングルール

### 2.1 JavaScript 基本ルール

```javascript
// ✅ 良い例
export async function loadModel(
  modelUrl,
  fileName = "model.glb",
  fileSize = 0
) {
  try {
    console.log("🔄 モデル読み込み開始:", { fileName, fileSize });
    const result = await processModel(modelUrl);
    console.log("✅ モデル読み込み完了");
    return result;
  } catch (error) {
    console.error("❌ モデル読み込みエラー:", error);
    throw new Error(`モデルの読み込みに失敗しました: ${error.message}`);
  }
}

// ❌ 悪い例
function loadModel(modelUrl) {
  // エラーハンドリングなし
  // ログなし
  // 非同期処理なし
}
```

### 2.2 Three.js 関連ルール

```javascript
// ✅ リソース管理の例
function disposeModelResources(modelData) {
  if (modelData.model) {
    // ジオメトリの破棄
    if (modelData.model.geometry) {
      modelData.model.geometry.dispose();
    }

    // マテリアルの破棄
    if (modelData.model.material) {
      if (Array.isArray(modelData.model.material)) {
        modelData.model.material.forEach((material) =>
          disposeMaterial(material)
        );
      } else {
        disposeMaterial(modelData.model.material);
      }
    }

    // テクスチャの破棄
    if (modelData.model.material) {
      const materials = Array.isArray(modelData.model.material)
        ? modelData.model.material
        : [modelData.model.material];

      materials.forEach((material) => {
        if (material.map) material.map.dispose();
        if (material.normalMap) material.normalMap.dispose();
        if (material.roughnessMap) material.roughnessMap.dispose();
      });
    }
  }
}
```

### 2.3 データ管理ルール

```javascript
// ✅ IndexedDB 使用例
export async function saveModelToIDB(modelId, data, meta = {}) {
  try {
    console.log("�� IndexedDB へモデル保存開始:", {
      modelId,
      dataSize: data?.size,
    });

    const enhancedMeta = {
      ...meta,
      modelId,
      size: data.size,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    await Promise.all([
      set(`${MODEL_KEY_PREFIX}${modelId}`, data),
      set(`${META_KEY_PREFIX}${modelId}`, enhancedMeta),
    ]);

    console.log("✅ IndexedDB モデル保存完了");
    return modelId;
  } catch (error) {
    console.error("❌ IndexedDB モデル保存エラー:", error);
    throw new Error(`モデルの保存に失敗しました: ${error.message}`);
  }
}
```

## 3. レスポンシブデザインルール

### 3.1 基本方針

- **主目的**: パソコンでの AR コンテンツ編集
- **モバイル対応**: 管理画面は必須としない
- **ウィンドウリサイズ**: 対応必須

### 3.2 対応範囲

```css
/* 最小幅: 1024px（ノートPC） */
@media (max-width: 1023px) {
  .editor-container {
    min-width: 1024px;
    overflow-x: auto;
  }
}

/* 最大幅: 2560px（4Kモニター） */
@media (min-width: 2561px) {
  .editor-container {
    max-width: 2560px;
    margin: 0 auto;
  }
}
```

### 3.3 レイアウト原則

```css
/* ✅ フレキシブルレイアウト */
.editor-grid-layout {
  display: grid;
  grid-template-columns: 300px 1fr 300px;
  gap: 20px;
  min-height: 100vh;
}

/* ✅ 相対単位使用 */
.editor-title {
  font-size: 1.5rem;
  line-height: 1.2;
}

/* ❌ 固定幅を避ける */
.editor-container {
  /* width: 1200px; ← 避ける */
}
```

## 4. UI/UX ルール

### 4.0 UI デザイン変更時の注意事項

**重要**: UIデザインを変更する際は、必ず他のファイル部分への干渉を防ぐこと

#### 4.0.1 干渉回避の原則

- **CSS スコープの確認**: 変更対象のスタイルが他のコンポーネントに影響しないか事前確認
- **グローバルスタイルの慎重な使用**: グローバルCSSの変更は全体への影響を検証してから実施
- **クラス名の重複チェック**: 新しいクラス名が既存のものと重複しないか確認

#### 4.0.2 干渉が発生しそうな場合の対応手順

1. **問題の特定**: どの部分が干渉するか詳細に分析
2. **回避策の検討**: 以下の手法を検討
   - CSS Modules の使用
   - BEM命名規則の適用
   - 特定のスコープ内でのスタイル限定
   - より具体的なセレクタの使用
3. **回避策の提示**: 修正前に回避策を明示
4. **安全な修正**: 回避策を適用してから修正実行

#### 4.0.3 推奨される安全な変更手法

```css
/* ✅ スコープを限定した安全な変更 */
.login-page .form-container {
  /* login-page内でのみ有効 */
}

/* ✅ 具体的なセレクタで干渉回避 */
.editor-view .button.primary {
  /* 特定のコンテキストでのみ有効 */
}

/* ❌ 干渉の可能性が高い変更 */
.button {
  /* 全体のbuttonに影響する危険性 */
}
```

### 4.1 インタラクション設計

```javascript
// ✅ ドラッグ&ドロップ対応
function setupDragAndDrop(uploadArea) {
  uploadArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    uploadArea.classList.add("highlight");
  });

  uploadArea.addEventListener("drop", async (event) => {
    event.preventDefault();
    uploadArea.classList.remove("highlight");

    const files = Array.from(event.dataTransfer.files);
    await handleFileUpload(files);
  });
}
```

### 4.2 ローディング表示

```javascript
// ✅ 適切なローディング表示
class LoadingManager {
  showLoadingScreen(options = {}) {
    const {
      message = "モデルを読み込んでいます...",
      container = document.body,
    } = options;

    const loadingElement = document.createElement("div");
    loadingElement.className = "loading-screen";
    loadingElement.innerHTML = `
      <div class="loading-spinner"></div>
      <div class="loading-message">${message}</div>
      <div class="loading-progress">
        <div class="progress-bar"></div>
      </div>
    `;

    container.appendChild(loadingElement);
    return loadingElement.id;
  }
}
```

### 4.3 エラーハンドリング

```javascript
// ✅ ユーザーフレンドリーなエラーメッセージ
function showNotification(message, type = "info") {
  const notification = document.createElement("div");
  notification.className = `notification notification-${type}`;
  notification.textContent = message;

  document.body.appendChild(notification);

  setTimeout(() => {
    notification.remove();
  }, 3000);
}
```

## 5. パフォーマンスルール

### 5.1 メモリ管理

```javascript
// ✅ リソースの適切な破棄
function cleanup() {
  // 3Dリソースの破棄
  scene.traverse((object) => {
    if (object.geometry) object.geometry.dispose();
    if (object.material) {
      if (Array.isArray(object.material)) {
        object.material.forEach((material) => disposeMaterial(material));
      } else {
        disposeMaterial(object.material);
      }
    }
  });

  // アニメーションミキサーの破棄
  animationMixers.forEach((mixer) => mixer.stopAllAction());
  animationMixers.clear();

  // レンダラーの破棄
  renderer.dispose();
}
```

### 5.2 60fps 維持

```javascript
// ✅ 最適化されたアニメーションループ
function animate() {
  requestAnimationFrame(animate);

  // デルタタイムを使用した滑らかなアニメーション
  const delta = clock.getDelta();

  // アニメーションミキサーの更新
  animationMixers.forEach((mixer) => mixer.update(delta));

  // レンダリング
  renderer.render(scene, camera);
}
```

## 6. 品質管理ルール

### 6.1 テスト戦略

```javascript
// ✅ ユニットテスト例
describe("ProjectStore", () => {
  test("プロジェクトの保存と読み込み", async () => {
    const testProject = {
      id: "test-project",
      name: "テストプロジェクト",
      models: [],
    };

    await saveProject(testProject);
    const loadedProject = await getProject("test-project");

    expect(loadedProject.name).toBe("テストプロジェクト");
  });
});
```

### 6.2 デバッグルール

```javascript
// ✅ 統一されたログ形式
const LOG_PREFIXES = {
  INFO: "ℹ️",
  SUCCESS: "✅",
  WARNING: "⚠️",
  ERROR: "❌",
  DEBUG: "��",
  LOADING: "��",
};

function log(level, message, data = null) {
  const prefix = LOG_PREFIXES[level] || "ℹ️";
  const timestamp = new Date().toISOString();

  console.log(`${prefix} [${timestamp}] ${message}`, data || "");
}
```

### 6.3 セキュリティルール

```javascript
// ✅ ファイルアップロード検証
function validateFileUpload(file) {
  const allowedTypes = ["model/gltf-binary", "model/gltf+json"];
  const maxSize = 50 * 1024 * 1024; // 50MB

  if (!allowedTypes.includes(file.type)) {
    throw new Error("サポートされていないファイル形式です");
  }

  if (file.size > maxSize) {
    throw new Error("ファイルサイズが大きすぎます（最大50MB）");
  }

  return true;
}
```

## 7. AR 機能固有ルール

### 7.1 マーカー型 AR

```javascript
// ✅ マーカー検出の最適化
function setupMarkerDetection() {
  const markerSize = 0.1; // 10cm
  const markerPattern = "data:image/png;base64,...";

  const marker = new THREE.Group();
  marker.add(createMarkerMesh(markerPattern, markerSize));

  return marker;
}
```

### 7.2 マーカーレス型 AR

```javascript
// ✅ 平面検出の実装
function setupPlaneDetection() {
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function onMouseClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planeMeshes);

    if (intersects.length > 0) {
      placeModelAt(intersects[0].point);
    }
  }
}
```

## 8. 最強の WEBAR 編集ツール要件

### 8.1 コード品質

- **美しいコード**: 可読性と保守性を重視
- **適切なコメント**: JSDoc 形式で詳細なドキュメント
- **エラーハンドリング**: 全ての非同期処理で try-catch
- **パフォーマンス**: 60fps 維持とメモリリーク防止

### 8.2 UI デザイン

- **超かっこいい UI**: モダンで洗練されたデザイン
- **直感的操作**: ドラッグ&ドロップ、リアルタイムプレビュー
- **アニメーション**: 滑らかなトランジション効果
- **一貫性**: 統一されたデザインシステム

### 8.3 使いやすさ

- **軽快な動作**: 最適化されたパフォーマンス
- **シンプル操作**: 複雑な設定を隠蔽
- **効率的ワークフロー**: 最小クリック数での操作
- **快適編集体験**: リアルタイムフィードバック

### 8.4 機能性

- **過不足ない機能**: 必要最小限の機能実装
- **拡張性**: プラグイン対応の設計
- **柔軟カスタマイズ**: 高度な設定オプション
- **効率的アセット管理**: IndexedDB 活用

### 8.5 品質管理

- **徹底テスト**: ユニット・統合・パフォーマンステスト
- **早期バグ発見**: 継続的インテグレーション
- **継続改善**: ユーザーフィードバック反映
- **品質維持**: 定期的なコードレビュー

## 公開ポリシー / 運用方針

### 基本方針

- 編集・保存はブラウザ内（IndexedDB / localStorage）
- 作品・個人情報はサーバーに保持しない（BYO ホスティング）
- 公開はユーザー自身の静的ホスティング（Vercel / Cloudflare Pages / GitHub Pages / S3 など）
- 共有は QR コード（固定ビューア URL に `?src=project.json` を付与）

### 推奨公開方法

- 標準: Web 公開（静的配信）＋ エクスポート ZIP（`project.json + assets + viewer.html`）
- 補完: LAN プレビュー（同一 Wi‑Fi での即時確認）
- 任意: ユーザーのクラウドにアップ（API キーは一時利用・保存禁止）

### 実装ガイド（要件）

- ルート: `#/viewer`（`?src=` の URL から `project.json` を fetch して表示）
- Export ZIP 構成: `project.json`, `assets/…`, `viewer.html`（相対パス参照）
- QR 発行 UI: タブ「Local(LAN) / Web（公開 URL）」＋ URL コピー / QR 再生成
- LAN 公開: 開発時 `server.host = true` で `http://<LAN-IP>:3000/` を QR 化

### 運用上の注意

- CORS 設定必須（公開先 CDN で `Access-Control-Allow-Origin: *` など）
- ライセンス・著作権はユーザー責任で確認
- 大容量 GLB は CDN 配信推奨／ZIP 配布時はサイズ注意
- API キーは保存しない（入力 → 当回のみ使用）
- バックアップ推奨（Export ZIP で取得）

### UI 文言ポリシー

- 「ログイン不要」「PC 専用」「ブラウザだけで編集・共有」を明示
- 公開は「ご自身のサーバー/クラウドに配置してください」と明記
- データ非保持を明言（安心感の提供）

### チェックリスト

- [ ] `#/viewer?src=` で表示できる
- [ ] Export ZIP が生成・動作する
- [ ] QR：Local/公開 URL 切替で URL が正しく変わる
- [ ] CORS / 大容量 / 著作権の注意文が UI に表示される

### 次の実装

- `src/views/ar-viewer.js`（`?src=`読込）
- QR 発行 UI に公開タブ/URL コピー追加
- Export ZIP（`project.json + assets + viewer.html`）

### 公開の流れ（3 分版）

- 事前準備（最初だけ）

  - 推奨ブラウザ: Chrome/Edge（PC）
  - 開発時 LAN 確認したい場合は設定を変更
    ```js
    // vite.config.js
    server: { host: true, port: 3000, strictPort: true }
    ```

- 1. 作成・保存（ローカル）

  - GLB をドラッグ&ドロップ
  - 編集 → 保存（IndexedDB/localStorage に保存）

- 2. その場で確認（LAN プレビュー）

  - 同一 Wi‑Fi のスマホから閲覧
  - ツール内の QR 発行でアクセス（例）
    ```
    http://<あなたのLAN IP>:3000/#/viewer?src=http://<LAN IP>:3000/public/projects/<id>/project.json
    ```

- 3. エクスポート（公開用）

  - Export ZIP を生成（構成例）
    ```
    project.json
    assets/...(glb, 画像)
    viewer.html（固定ビューア、?src=対応）
    ```

- 4. 公開（ユーザー自身のホスティング）

  - 置き場所（どれでも OK）
    - Vercel / Cloudflare Pages / Netlify（ドラッグ&ドロップ）
    - GitHub Pages（リポに push）
    - S3 + CloudFront（CDN）
  - 公開後の URL 例
    ```
    https://your-domain.com/viewer.html?src=https://your-domain.com/projects/xxx/project.json
    ```

- 5. 共有（QR）

  - 公開 URL を QR 化（ツールの QR 発行 UI で URL 貼付 → 生成）
  - 印刷・配布・SNS などに利用

- 6. 更新
  - エクスポート → 同じ場所へ上書き
  - URL/QR は固定のまま更新反映

#### 注意（短縮）

- CORS: 公開先で静的配信の CORS を許可（`Access-Control-Allow-Origin: *` 推奨）
- 大容量 GLB は CDN 配信推奨
- 著作権・ライセンスは各自確認
- ツールはデータを保持しない（BYO ホスティング）

- まとめ
  - Web 公開が基本（無料枠で OK）、LAN プレビューと ZIP エクスポートで即運用可能
  - 固定のビューア URL に`?src=project.json`を渡す形が最もシンプルで拡張性 ◎
